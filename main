#include <iostream>
#include <fstream>
#include <bits/stdc++.h>
#include <cmath>
#include <bitset>
using namespace std;


int mmBlkNum(int memoryLocation, int cacheBlockSize){
        return memoryLocation/cacheBlockSize;
}

int cmSetNum(int memoryLocation, int cacheBlockSize, int cacheMemorySize, int associativity){
        int mmBlk = mmBlkNum(memoryLocation, cacheBlockSize);
        return mmBlk % ((cacheMemorySize / cacheBlockSize) / associativity);
}

int cmBlkNum(int memoryLocation, int cacheBlockSize, int cacheMemorySize, int associativity){
        int cmSet = cmSetNum(memoryLocation, cacheBlockSize, cacheMemorySize, associativity);
        return cmSet * associativity;
}

int main(){

bool cont = 1;

while(cont == 1){

        cout << "Enter the size of main memory in bytes: ";
        int mainMemorySize;
        cin >> mainMemorySize;

        cout << "Enter the size of the cache in bytes: ";
        int cacheMemorySize;
        cin >> cacheMemorySize;

        cout << "Enter the cache block/line size: ";
        int cacheBlockSize;
        cin >> cacheBlockSize;

        cout << "\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ";
        int associativity;
        cin >> associativity;

        cout << "Enter the replacement policy (L = LRU, F = FIFO): ";
        char replacementPolicy;
        cin >> replacementPolicy;

        cout << "\nEnter the name of the input file containing the list of memory references generated by the CPU: ";
        string fileName = "p7.txt";
        //cin >> fileName;
        ifstream inFile;
        inFile.open(fileName);
        if(!inFile){
                cerr << "Unable to open file " << fileName;
                exit(1);
        }
        cout << "\n";

        int numOfReferences;

        inFile >> numOfReferences;

        vector<char> readWrite;
        char fileChar;
        vector<int> memLoc;
        int fileInt;
        while(!inFile.eof()){
                inFile >> fileChar;
                readWrite.push_back(fileChar);
                inFile >> fileInt;
                memLoc.push_back(fileInt);
        }

        int hitCnt = 0;
        int cacheSize = cacheMemorySize / cacheBlockSize;
        bool dirtyBit[cacheSize] = {0};
        bool validBit[cacheSize] = {0};
        int tagSize = log2((mainMemorySize / cacheMemorySize) * associativity);
        int tag[cacheSize][tagSize];
        int dataNum[cacheSize];
        int fifo[cacheSize] = {0};
        int lru[cacheSize] = {0};
        for(int x = 0; x < cacheSize; x++){
                dataNum[x] = -1;
        }
        int numCacheBlocks = cacheSize / cacheBlockSize;


        cout << "Simulator Output:\n";
        cout << "Total address lines required = " << log2(mainMemorySize) << "\n";
        cout << "Number of bits for offset = " << log2(cacheBlockSize) << "\n";
        cout << "Number of bits for index = " << log2(mainMemorySize) - log2(cacheBlockSize) - tagSize << "\n";
        cout << "Number of bits for tag = " << tagSize << "\n";
        cout << "Total cache size required = " << cacheMemorySize + (cacheMemorySize / cacheBlockSize / 8) + tagSize << "\n";
        cout << "\n";

        cout << "main memory address    mm blk #       cm set #          cm blk #          hit/miss" << endl;
        cout << "_______________________________________________________________________________\n";
        for(int i = 0; i < memLoc.size(); i++){
                bool isInCache = 0;
                cout << "       " << memLoc.at(i);
                if(memLoc.at(i) < 100){cout << " ";}
                if(memLoc.at(i) < 10) {cout << " ";}
                int mmBlk = mmBlkNum(memLoc.at(i), cacheBlockSize);
                cout << "             " << mmBlk;
                if(mmBlk < 100){cout << " ";}
                if(mmBlk < 10) {cout << " ";}
                int cmSet = cmSetNum(memLoc.at(i), cacheBlockSize, cacheMemorySize, associativity);
                cout << "              " << cmSet;
                if(cmSet < 100){cout << " ";}
                if(cmSet < 10) {cout << " ";}
                int cmBlk = cmBlkNum(memLoc.at(i), cacheBlockSize, cacheMemorySize, associativity);
                cout << "                " << cmBlk << "-" << cmBlk + (associativity - 1);
                if(cmBlk < 100){cout << "  ";}
                if(cmBlk < 10) {cout << "  ";}

                /*************/

                int cmBlkSearch = 0;
                while(isInCache == 0 && cmBlkSearch < associativity){
                        if(dataNum[cmBlk + cmBlkSearch] == memLoc.at(i) / cacheBlockSize && validBit[cmBlk] == 1){
                                isInCache = 1;
                                cout << "            hit";
                                hitCnt++;
                                for(int a = 0; a < numCacheBlocks; a++){
                                        fifo[a]++;
                                        lru[a]++;
                                }
                                lru[cmBlk] = 0;
                        }
                        else{
                                isInCache = 0;
                                cmBlkSearch++;
                        }
                }

                int cacheOffset = 0;
                while(isInCache == 0){
                        cout << "            miss";
                        while(validBit[cmBlk + cacheOffset] == 1 && cacheOffset < associativity){
                                cacheOffset++;
                        }
                        if(cacheOffset == associativity && replacementPolicy == 'L'){
                                int oldestIndex;
                                int maxAgelru = 0;
                                for(int a = 0; a < associativity; a++){
                                        if(lru[a] > maxAgelru){
                                                maxAgelru = lru[a];
                                                oldestIndex = a;
                                        }
                                }
                                dataNum[oldestIndex] = mmBlk;
                                lru[oldestIndex] = 0;
                                for(int b = 0; b < numCacheBlocks; b++){
                                        if(validBit[b] == 1){
                                                lru[b]++;
                                        }
                                }
                        }
                        else if(cacheOffset == associativity && replacementPolicy == 'F'){
                                int oldestIndex;
                                int maxAgefifo = 0;
                                for(int a = 0; a < associativity; a++){
                                        if(fifo[a] > maxAgefifo){
                                                maxAgefifo = fifo[a];
                                                oldestIndex = a;
                                        }
                                }
                                dataNum[oldestIndex] = mmBlk;
                                fifo[oldestIndex] = 0;
                                for(int b = 0; b < numCacheBlocks; b++){
                                        if(validBit[b] == 1){
                                                fifo[b]++;
                                        }
                                }
                        }
                        else{
                                dataNum[cmBlk + cacheOffset] = mmBlk;
                                validBit[cmBlk + cacheOffset] = 1;
                                for(int c = 0; c < numCacheBlocks; c++){
                                        fifo[c]++;
                                        lru[c]++;
                                }
                        }
                        for(int i = 0; i < tagSize; i++){
                                int tagNum = ((int)mmBlk - 1) / pow(2, tagSize+1-i);
                                int tagNum1 = int(tagNum) % 2;
                                tag[cmBlk + cacheOffset][i] = tagNum1;
                        }
                        isInCache = 1;
                }

                /*************/

                cout << "\n";
        }

        cout << "\n\n";
        cout << "Highest possible hit rate = \n";
        cout << "Actual hit rate = " << hitCnt << "/" << numOfReferences << " = " << (hitCnt * 100) / numOfReferences << "%\n\n";
        cout << "Final \"status\" of the cache:\n";

        cout << "Cache blk #    dirty bit       valid bit       tag        Data\n";
        cout << "______________________________________________________________\n";
        for(int y = 0; y < cacheSize; y++){
                cout << "      " << y;
                if(y < 100){cout << " ";}
                if(y < 10) {cout << " ";}
                cout << "           " << dirtyBit[y];
                cout << "               " << validBit[y];
                cout << "           ";
                if(validBit[y] == 0){
                        cout << "xxx";
                }
                else{
                        for(int z = 0; z < tagSize; z++){
                                cout << tag[y][z];
                        }
                }
                cout << "      ";
                if(validBit[y] == 0){
                        cout << "   xxx";
                }
                else{
                        cout << "mm blk # " << dataNum[y];
                }
                cout << "\n";
        }
        cout << "\n";

        inFile.close();
        char yesOrNo;
        while(yesOrNo != 'y' && yesOrNo != 'n'){
                cout << "Continue? (y = yes, n = no): ";
                cin >> yesOrNo;
                if(yesOrNo == 'y'){
                        cont = 1;
                }
                else if(yesOrNo == 'n'){
                        cont = 0;
                }
                else{
                        cout << "Invalid input\n";
                }
        }
}
        return 0;
}
