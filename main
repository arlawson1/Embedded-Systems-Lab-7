// This code was written by Andrew Lawson
// CWID 1187 8082

// This program simulates the movement from main memory to cache memory
//      with several different options on how to do so, including options
//      to change the main memory size, the cache memory size, the block size,
//      the set associativity, and the replacement policy.


#include <iostream>
#include <fstream>
#include <bits/stdc++.h>
#include <cmath>
using namespace std;

string printTag(int mainMemorySize, int cacheMemorySize, int cacheBlockSize, int associativity, int mmBlkNum){
        // number of bits for tag is (# MM blocks / assoc)
        // int mainMemorySize, int cacheMemorySize, int cacheBlockSize, int associativity, int mmBlk
        string tagToPrint = "";
        int numMM_blocks = mainMemorySize / cacheBlockSize;
        int numBits = log2(numMM_blocks / ((cacheMemorySize / cacheBlockSize) / associativity));
        // tag = MM block # / set associativity
        int tag = mmBlkNum / ((cacheMemorySize / cacheBlockSize) / associativity);
        for(int i = numBits; i > 0; i--){
                if(tag >= pow(2, i-1)){
                        tagToPrint += "1";
                        tag = tag - pow(2, i-1);
                }
                else{
                        tagToPrint += "0";
                }
        }
        return tagToPrint;
}

// function to solve for the number of blocks that the main memory will be split into
int mmBlkNum(int memoryLocation, int cacheBlockSize){
        return memoryLocation/cacheBlockSize;
}

// function to solve for the number of sets that the cache memory will be split into
int cmSetNum(int memoryLocation, int cacheBlockSize, int cacheMemorySize, int associativity){
        int mmBlk = mmBlkNum(memoryLocation, cacheBlockSize);
        return mmBlk % ((cacheMemorySize / cacheBlockSize) / associativity);
}

// function to solve for the number of blocks that the chache memory will be split into
int cmBlkNum(int memoryLocation, int cacheBlockSize, int cacheMemorySize, int associativity){
        int cmSet = cmSetNum(memoryLocation, cacheBlockSize, cacheMemorySize, associativity);
        return cmSet * associativity;
}

// function to find the number of total dirty bits that the cache will have
int numOfDirtyBits(int cacheMemorySize, int cacheBlockSize){
        return cacheMemorySize / cacheBlockSize / 8;
}

// function to dummy-proof the user inputs so that they are always a power of 2
bool isPowerOfTwo(int n){
        if(n == 0){
                return 0;
        }
        while(n != 1){
                if(n % 2 != 0){
                        return 0;
                }
                n = n / 2;
        }
        return 1;
}

// IN PROGRESS function to find the tag number and print it as binary code
void tagMaker(int mainMemorySize, int cacheMemorySize, int cacheBlockSize, int associativity, int mmBlk){
        int numMMblocks = mainMemorySize / cacheBlockSize;
        int numCMsets = (cacheMemorySize / cacheBlockSize) / associativity;
        int maxTagNum = numMMblocks / numCMsets;
        int numTagBits = log2(maxTagNum);
        int tagNum = mmBlk / ((cacheMemorySize / cacheBlockSize) / associativity);
        for(int i = numTagBits; i > 0; i--){
                if((tagNum / pow(2,i-1)) == 1){
                        cout << "1";
                }
                else{
                        cout << "0";
                }
        }
}

int main(){

// boolean that when set to 0 ends the program
bool cont = 1;

// MAIN LOOP
while(cont == 1){

        cout << "\n\nEnter the size of main memory in bytes: ";
        int mainMemorySize;
        cin >> mainMemorySize;
        // A loop to dummy-proof main memory size so that it is always a power of 2 with a minimum size of 4 bytes
        // This loop is a template for most of the error checking loops used during the input process
        while(!isPowerOfTwo(mainMemorySize) || mainMemorySize < 4){
                cerr << "Not a power of 2, please enter a main memory size that is a multiple of 2 : ";
                cin >> mainMemorySize;
        }

        cout << "Enter the size of the cache in bytes: ";
        int cacheMemorySize;
        cin >> cacheMemorySize;
        while(!isPowerOfTwo(cacheMemorySize) || cacheMemorySize < 2){
                cerr << "Not a power of 2, please enter a cache memory size that is a multiple of 2 : ";
                cin >> cacheMemorySize;
        }

        cout << "Enter the cache block/line size: ";
        int cacheBlockSize;
        cin >> cacheBlockSize;
        while(!isPowerOfTwo(cacheBlockSize) || cacheBlockSize < 2){
                cerr << "Not a power of 2, please enter a cache block size that is a multiple of 2 : ";
                cin >> cacheBlockSize;
        }

        cout << "\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ";
        int associativity;
        cin >> associativity;
        while(!isPowerOfTwo(associativity) && associativity != 1){
                cerr << "Not a valid set associativity, please enter an associativity that is either 1 (direct-mapped) or a power of 2 : ";
                cin >> associativity;
        }

        cout << "Enter the replacement policy (L = LRU, F = FIFO): ";
        char replacementPolicy;
        cin >> replacementPolicy;
        while(replacementPolicy != 'L' && replacementPolicy != 'F'){
                cerr << "Not a valid replacement policy, please enter either 'L' for least-recently-used or 'F' for first-in-first-out : ";
                cin >> replacementPolicy;
        }

        cout << "\nEnter the name of the input file containing the list of memory references generated by the CPU: ";
        string fileName;
        cin >> fileName;
        ifstream inFile;
        inFile.open(fileName);
        // Loop to catch an error in opening the file name. Loops until a valid file name is given.
        while(!inFile){
                cerr << "Unable to open file " << fileName << ", try a different file : ";
                cin >> fileName;
                inFile.open(fileName);
        }
        cout << "\n";

        // int to capture the number of reads/writes in the given text file
        int numOfReferences;

        inFile >> numOfReferences;

        // vector to read in all R's or W's
        vector<char> readWrite;
        char fileChar;
        // vector to read in all memory locations being accessed
        vector<int> memLoc;
        int fileInt;
        while(!inFile.eof()){
                inFile >> fileChar;
                readWrite.push_back(fileChar);
                inFile >> fileInt;
                memLoc.push_back(fileInt);
        }

        // ints for the number of hits and calculating the size of the cache in blocks
        int hitCnt = 0;
        int cacheSize = cacheMemorySize / cacheBlockSize;
        // arrays of booleans for dirty bits and valid bits
        bool dirtyBit[cacheSize] = {0};
        bool validBit[cacheSize] = {0};
        // int for calculating the number of bits in a tag and an array of ints to capture the MM block #s
        int tagSize = log2((mainMemorySize / cacheMemorySize) * associativity);
        int dataNum[cacheSize];
        // arrays of ints to keep track of the age of each valid block of data (used in the replacement policies)
        int fifo[cacheSize] = {0};
        int lru[cacheSize] = {0};
        // array to keep track of which MM block # gets read or written to (used in calculating best possible hit rate)
        int mmBlkCnt[(mainMemorySize / cacheBlockSize)];

        // loops to initialize all ints in mmBlkCnt and dataNum to -1
        // initialized to -1 so they can act as "flags" for other functions later in the program
        for(int i = 0; i < mainMemorySize / cacheBlockSize; i++){
                mmBlkCnt[i] = -1;
        }
        for(int x = 0; x < cacheSize; x++){
                dataNum[x] = -1;
        }


        cout << "Simulator Output:\n";
        cout << "Total address lines required = " << log2(mainMemorySize) << "\n";
        cout << "Number of bits for offset = " << log2(cacheBlockSize) << "\n";
        cout << "Number of bits for index = " << log2(mainMemorySize) - log2(cacheBlockSize) - tagSize << "\n";
        cout << "Number of bits for tag = " << tagSize << "\n";
        // cache memory bytes + bytes of valid bits + bytes of tag bits + bytes of dirty bits
        cout << "Total cache size required = " << cacheMemorySize + (cacheMemorySize / cacheBlockSize / 8) + tagSize + numOfDirtyBits(cacheMemorySize, cacheBlockSize) << "\n";
        cout << "\n";

        // table of inputs
        cout << "main memory address    mm blk #       cm set #          cm blk #          hit/miss" << endl;
        cout << "__________________________________________________________________________________\n";
        for(int i = 0; i < numOfReferences; i++){
                // bool used later to detect cache hits
                bool isInCache = 0;
                cout << "      " << memLoc.at(i);
                // creates more space in the event of a memory address being smaller than the biggest one acceptable
                if(memLoc.at(i) < 1000){cout << " ";}
                if(memLoc.at(i) < 100){cout << " ";}
                if(memLoc.at(i) < 10) {cout << " ";}
                int mmBlk = mmBlkNum(memLoc.at(i), cacheBlockSize);
                cout << "               " << mmBlk;
                if(mmBlk < 100){cout << " ";}
                if(mmBlk < 10) {cout << " ";}
                int cmSet = cmSetNum(memLoc.at(i), cacheBlockSize, cacheMemorySize, associativity);
                cout << "            " << cmSet;
                if(cmSet < 100){cout << " ";}
                if(cmSet < 10) {cout << " ";}
                int cmBlk = cmBlkNum(memLoc.at(i), cacheBlockSize, cacheMemorySize, associativity);
                cout << "              " << cmBlk << "-" << cmBlk + (associativity - 1);
                if(cmBlk < 100){cout << "  ";}
                if(cmBlk < 10) {cout << "  ";}

                /*************/

                // int used to search a cache memory set (used to detect cache hits)
                int cmBlkSearch = 0;
                // loop to search all blocks in a given cache memory set for a matching main memory block
                while(isInCache == 0 && cmBlkSearch < associativity){
                        if(dataNum[cmBlk + cmBlkSearch] == memLoc.at(i) / cacheBlockSize && validBit[cmBlk +cmBlkSearch] == 1){
                                isInCache = 1;
                                cout << "          hit";
                                // sets dirty bit if the address is being written to
                                if(readWrite.at(i) == 'W'){
                                        dirtyBit[cmBlk + cmBlkSearch] = 1;
                                }
                                // hit counter increases; best possible hit counter increases
                                hitCnt++;
                                mmBlkCnt[mmBlk]++;
                                // loop to increase the age of all valid cache memory blocks
                                for(int a = 0; a < cacheSize; a++){
                                        if(validBit[a] == 1){
                                                fifo[a]++;
                                                lru[a]++;
                                        }
                                }
                                // reset the least recently used block's age
                                lru[cmBlk + cmBlkSearch] = 0;
                        }
                        else{
                                isInCache = 0;
                                cmBlkSearch++;
                        }
                }

                // similar to cmBlkSearch, used to offset the index of the cache memory block
                int cacheOffset = 0;
                while(isInCache == 0){
                        cout << "          miss";
                        // resets the "flag" for a specific main memory block; used in calculating best possible hit rate
                        if(mmBlkCnt[mmBlk] == -1){
                                mmBlkCnt[mmBlk] = 0;
                        }
                        // if the "flag" has been reset, the main memory block counter starts increasing with each potential hit
                        else if(mmBlkCnt[mmBlk] >= 0){
                                mmBlkCnt[mmBlk]++;
                        }
                        // loop to check for an "empty spot" in a cache memory set
                        while(validBit[cmBlk + cacheOffset] == 1 && cacheOffset < associativity){
                                cacheOffset++;
                        }
                        // two similar conditional statements to calculate which block to replace when a set is "full"
                        if(cacheOffset == associativity && replacementPolicy == 'L'){
                                int oldestIndex = 0;
                                int maxAgelru = -999;
                                for(int a = cmBlk; a < cmBlk + associativity; a++){
                                        if(lru[a] > maxAgelru){
                                                maxAgelru = lru[a];
                                                oldestIndex = a;
                                        }
                                }
                                dataNum[oldestIndex] = mmBlk;
                                lru[oldestIndex] = 0;
                                for(int b = 0; b < cacheSize; b++){
                                        if(validBit[b] == 1){
                                                lru[b]++;
                                        }
                                }
                        }
                        else if(cacheOffset == associativity && replacementPolicy == 'F'){
                                int oldestIndex;
                                int maxAgefifo = -999;
                                for(int a = cmBlk; a < cmBlk + associativity; a++){
                                        if(fifo[a] > maxAgefifo){
                                                maxAgefifo = fifo[a];
                                                oldestIndex = a;
                                        }
                                }
                                dataNum[oldestIndex] = mmBlk;
                                fifo[oldestIndex] = 0;
                                for(int b = 0; b < cacheSize; b++){
                                        if(validBit[b] == 1){
                                                fifo[b]++;
                                        }
                                }
                        }
                        // else if the cache is not full, write into the next "open" cache memory block
                        else{
                                dataNum[cmBlk + cacheOffset] = mmBlk;
                                validBit[cmBlk + cacheOffset] = 1;
                                for(int c = 0; c < cacheSize; c++){
                                        if(validBit[c] == 1){
                                                fifo[c]++;
                                                lru[c]++;
                                        }
                                }
                        }
                        // the main memory block is now in the cache and the loop can safely end
                        isInCache = 1;
                        // if the address was written to, set the dirty block
                        if(readWrite.at(i) == 'W'){
                                dirtyBit[cmBlk + cacheOffset] = 1;
                        }
                        // reset the dirty bit if the main memory block in the cache is being replaced by a read operation
                        else if(readWrite.at(i) == 'R' && dirtyBit[cmBlk + cacheOffset] == 1){
                                        dirtyBit[cmBlk + cacheOffset] = 0;
                                }
                }

                /*************/

                cout << "\n";
        }

        int bestPossibleHitRate = 0;
        // loop to sum up the best possible hit rate
        for(int i = 0; i < mainMemorySize / cacheBlockSize; i++){
                if(mmBlkCnt[i] > 0){
                        bestPossibleHitRate += mmBlkCnt[i];
                }
        }

        // table displaying the contents of the cache
        cout << "\n\n";
        cout << "Highest possible hit rate = " << bestPossibleHitRate << "/" << numOfReferences << " = " << (bestPossibleHitRate * 100) / numOfReferences << "%\n";
        cout << "Actual hit rate = " << hitCnt << "/" << numOfReferences << " = " << (hitCnt * 100) / numOfReferences << "%\n\n";
        cout << "Final \"status\" of the cache:\n";

        cout << "Cache blk #    dirty bit       valid bit        tag        Data\n";
        cout << "_______________________________________________________________\n";
        for(int y = 0; y < cacheSize; y++){
                cout << "      " << y;
                if(y < 100){cout << " ";}
                if(y < 10) {cout << " ";}
                cout << "           " << dirtyBit[y];
                cout << "               " << validBit[y];
                cout << "           ";
                if(validBit[y] == 0){
                        cout << "xxx";
                }
                else{
                        cout << printTag(mainMemorySize, cacheMemorySize, cacheBlockSize, associativity, dataNum[y]);
                }
                cout << "      ";
                if(validBit[y] == 0){
                        cout << "   xxx";
                }
                else{
                        cout << "mm blk # " << dataNum[y];
                }
                cout << "\n";
        }
        cout << "\n";

        inFile.close();
        char yesOrNo;
        // loop to ask the user if they would like to run the program again
        while(yesOrNo != 'y' && yesOrNo != 'n'){
                cout << "Continue? (y = yes, n = no): ";
                cin >> yesOrNo;
                if(yesOrNo == 'y'){
                        cont = 1;
                }
                else if(yesOrNo == 'n'){
                        cont = 0;
                }
                else{
                        cout << "Invalid input\n";
                }
        }
}
        return 0;
}
